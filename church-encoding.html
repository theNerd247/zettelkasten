<p>Church encoding is the idea that data structures can be modelled as functions in the lambda calculus. The trick is to change how we view what a datastructure is used. Normally we would say it’s something that stores data for a purpose.</p>
<p>Church encoding says datastructures are a collection of functions that define what to do with that data. Take a list, for example. A list is a finite collection of things in a linear order. In C this is modelled closely to how the computer is physically wired<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. In Haskell a list is defined recursively as:</p>
<pre><code>List a = Nil | Cons a List

Nil : List a
Cons a : a → List a → List a</code></pre>
<p><code>Nil</code> is the empty list, and <code>Cons</code> stiches an element (called the “head”) of type <code>a</code> to another list (called the “tail”). Both the C and Haskell ideas of a list only discuss the structure of the data in the list.</p>
<p>But data that’s just sitting around is useless. It’s like having a bunch of parts to a car without ever building it - useless. And that’s the idea behind Church encoding. Here’s the Church encoding for lists:</p>
<pre><code>ListC a b = b → (a → (ListC a b) → b) → b</code></pre>
<p>It’s a function! A function with 2 arguments: one for each constructor from the Haskell list:</p>
<pre><code>ListC a b 
  -- the value to return if we have a null list
  = b  
  -- the function to run to get a return value from the head and tail of the
  -- list
  → (a → b → b) 
  → b</code></pre>
<p><code>Nil</code> and <code>Cons</code> can then be re written as:</p>
<pre><code>nil = \b f -&gt; b
cons x xs = \b f -&gt; f x (xs b f)</code></pre>
<p>Notice how the recursive reference for the <code>List</code> in the original definition gets replaced with a type variable <code>b</code> in <code>ListC</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. This <code>b</code> type represents the type of value the list will eventually be used to evaluate to. This is how we think of lists as not just a data structure, but what to do with the datastructure.</p>
<p>This new way of thinking is called a “fold”. A fold is just a way to “evaluate” a datastructure into a single value of some type.</p>
<p>Here’s an example list constructed from the above Church encoded list:</p>
<pre><code>one 
  = cons 1 nill                   (from def. of ListC)
  = \b f -&gt; f 1 ((\b f -&gt; b) b f) (expanding to lambda form)
  = \b f -&gt; f 1 b                 (simplifying inner redux)</code></pre>
<p>Notice what <code>cons 1 nill</code> turns into: a function that calls <code>f</code> with <code>1</code> and <code>b</code>. It’s like this new form goes ahead and wires our logic of how to handle this list into the values of the list. Here’s what I mean.</p>
<p>Let’s say that you want to count the elements in a list. To solve this let’s just think about the return type. What type describes the result of counting a list? Of course! Natural numbers<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>! So we need a function of type <code>ListC a b → Nat</code>. What should we put for the <code>b</code> type? Well look at the definition of <code>ListC</code>. The <code>b</code> reprents the result of evaluating our list, in this case <code>Nat</code>. So our function will be:</p>
<pre><code>countL :: ListC a Nat → Nat
countL = ???</code></pre>
<p>So how do we count this list? Well let’s take each case in mind. What happens if the list is empty? Then we return <code>0</code>. But because our <code>ListC</code> doesn’t have a constructor for the empty list we can’t just pattern match on the incoming list to see if it’s empty. And it would be unwise to have a separate function to check if the list is empty or not<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Remember the definition of our <code>ListC</code>. It is a function that takes in the result for when the list is empty, and a function for what to do when the list is not empty. So all we need to do in order to handle the empty case is to pass our default value to this function:</p>
<pre><code>countL :: ListC a Nat → Nat
countL list = list 0 ??? </code></pre>
<p>And if it’s not empty? Well by the definition of <code>ListC</code> someone who created the list we’re evaluating would have already done the work of extracting the head and tail from the list. All we need to do is write a function of type <code>a → b → b</code> or in this case <code>a → Nat → Nat</code>. This function, which we define, tells the list function what to do with a single element of the list and the result after having evaluated the rest of the list already. Here’s that function:</p>
<pre><code>increaseSize :: a → Nat → Nat
increaseSize a sizeOfTail = 1 + sizeOfTail</code></pre>
<p>And to tie everything together we pass the <code>increaseSize</code> function as the second argument of the list. Here’s everything in one snapshot:</p>
<pre><code>countL :: ListC a Nat → Nat
countL list = list 0 increaseSize 

increaseSize :: a → Nat → Nat
increaseSize a sizeOfTail = 1 + sizeOfTail</code></pre>
<div id="tag-links" class="tag-links">
<p><a href="./lambda-calculus.html" id="tag-link" class="tag-link" title="lambda-calculus">(see lambda-calculus)</a></p>
<p><a href="./datastructures.html" id="tag-link" class="tag-link" title="datastructures">(see datastructures)</a></p>
<p><a href="./programming.html" id="tag-link" class="tag-link" title="programming">(see programming)</a></p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For the curious this is done using pointers <a href="./arrays-in-c.html">(see arrays-in-c)</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>This is extremely related to F-Algebras and encoding recursive types with them<a href="./f-algebras-recursive-types.html">(see f-algebras-recursive-types)</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>No! Not <code>Int</code> or <code>Num</code>! Why? <code>Int</code> contains negatives. <code>Num</code> could be a decimal! We don’t want bugs creeping into our code where we could have a list of length 0.5 or -2. Natural numbers are: 0, 1, 2, …<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>This isn’t Java or some other imperative language. If statements can typically be avoided in functional programming.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
