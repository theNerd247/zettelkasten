<p>Church encoding is the idea that data structures can be modelled as functions in the lambda calculus. The trick is to change how we view what a datastructure is used. Normally we would say it’s something that stores data for a purpose.</p>
<p>Church encoding says datastructures are a collection of functions that define what to do with that data. Take a list, for example. A list is a finite collection of things in a linear order. In C this is modelled closely to how the computer is physically wired<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. In Haskell a list is defined recursively as:</p>
<pre><code>List a = Nil | Cons a List

Nil : List a
Cons a : a → List a → List a</code></pre>
<p><code>Nil</code> is the empty list, and <code>Cons</code> stiches an element (called the “head”) of type <code>a</code> to another list (called the “tail”). Both the C and Haskell ideas of a list only discuss the structure of the data in the list.</p>
<p>But data that’s just sitting around is useless. It’s like having a bunch of parts to a car without ever building it - useless. And that’s the idea behind Church encoding. Here’s the Church encoding for lists:</p>
<pre><code>ListC a b = b → (a → (ListC a b) → b) → b</code></pre>
<p>It’s a function! A function with 2 arguments: one for each constructor from the Haskell list:</p>
<pre><code>ListC a b 
  -- the value to return if we have a null list
  = b  
  -- the function to run to get a return value from the head and tail of the
  -- list
  → (a → b → b) 
  → b</code></pre>
<p><code>Nil</code> and <code>Cons</code> can then be re written as:</p>
<pre><code>nil = \b f -&gt; b
cons x xs = \b f -&gt; f x (xs b f)</code></pre>
<p>Notice how the recursive reference for the <code>List</code> in the original definition gets replaced with a type variable <code>b</code> in <code>ListC</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. This <code>b</code> type represents the type of value the list will eventually be used to evaluate to. This is how we think of lists as not just a data structure, but what to do with the datastructure.</p>
<p>This new way of thinking is called a “fold”. A fold is just a way to “evaluate” a datastructure into a single value of some type.</p>
<p>Here’s an example list constructed from the above Church encoded list:</p>
<pre><code>one 
  = cons 1 nill                   (from def. of List&#39;)
  = \b f -&gt; f 1 ((\b f -&gt; b) b f) (expanding to lambda form)
  = \b f -&gt; f 1 b                 (simplifying inner redux)</code></pre>
<p>Notice what <code>cons 1 nill</code> turns into: a function that calls <code>f</code> with <code>1</code> and <code>b</code>. It’s like this new form goes ahead and wires our logic of how to handle this list into the values of the list. Here’s what I mean.</p>
<p>Let’s say that you want <code></code></p>
<div id="tag-links" class="tag-links">
<p><a href="./lambda-calculus.html" id="tag-link" class="tag-link" title="lambda-calculus">(see lambda-calculus)</a></p>
<p><a href="./datastructures.html" id="tag-link" class="tag-link" title="datastructures">(see datastructures)</a></p>
<p><a href="./programming.html" id="tag-link" class="tag-link" title="programming">(see programming)</a></p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For the curious this is done using pointers <a href="./arrays-in-c.html">(see arrays-in-c)</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>This is extremely related to F-Algebras and encoding recursive types with them<a href="./f-algebras-recursive-types.html">(see f-algebras-recursive-types)</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
