<p>So in Haskell <code>Maybe</code> is a type. <code>Maybe : * → *</code> is the relation between <code>Maybe</code> the type and it’s kind (<code>* → *</code>). But, what if we didn’t have function kinds?</p>
<p>Currently the kind language is:</p>
<pre><code>kinds ≡ k := * | (→) k k</code></pre>
<p>But what if we want <code>k' := *</code>? What happens to <code>Maybe</code>?</p>
<p>Well … let’s start with terms and reconstruct maybe in the untyped lambda calculus<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Then we’ll add on types, then kinds and see where this leads us. First, we don’t have a language yet for data constructors so we’ll need to use church encoding for our data constructors.</p>
<pre><code>Terms
nothing :=   λn j. n
just    := λx n j. j x

Types
nothing : T₂ → (T₁ → T₂) → T₂
just    : T₁ → T₂ → (T₁ → T₂) → T₂

Kinds
nothing : *
just    : *</code></pre>
<p>We have a problem. What do we put down for <code>T₁</code>? This is the type of the thing we’re storing in the <code>Maybe</code>. For example <code>T₁</code> could be <code>Int</code> and then <code>just 2 : Maybe Int``Maybe</code> in the general sense works for any time <code>T₁</code> (should be polymorphic)! If we are sticking to simply typed lambda calculus<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> then this is not possible because we don’t have type-level lambdas<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>There’s another problem. What do we put for <code>T₂</code>? This is the type that a <code>Maybe T₁</code> should evaluate to. Well…</p>
<pre><code>t := … | λx:T.t | …</code></pre>
<p>So. a <code>Maybe Int</code> would be written as:</p>
<pre><code>λx:Int n:Int j:(Int → Int). j x</code></pre>
<p>Now what if we really want polymorphism? Then we’d need to extend to using System-F.</p>
<pre><code>∀a.∀b.λx:a n:b j:(a → b) . j x </code></pre>
<p>Here we don’t explicitly state the type of the inputs. Instead we put a type lambda (<code>∀</code>) that turns the 3 variable <code>just</code> into a 5 variable function. The extra 2 variables at the beginning are type variables that are used to form the types of the incoming terms.</p>
<div id="tag-links" class="tag-links">
<p><a href="./lambda-calculus.html" id="tag-link" class="tag-link" title="lambda-calculus">(see lambda-calculus)</a></p>
<p><a href="./types.html" id="tag-link" class="tag-link" title="types">(see types)</a></p>
<p><a href="./polymorphism.html" id="tag-link" class="tag-link" title="polymorphism">(see polymorphism)</a></p>
<p><a href="./system-f.html" id="tag-link" class="tag-link" title="system-f">(see system-f)</a></p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>We’re actually using the untyped lambda calculus where <code>c := {()} ∪ N</code> - constants are the unit value and the natural numbers.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>We’re actually using the untyped lambda calculus where <code>c := {()} ∪ N</code> - constants are the unit value and the natural numbers.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Put another way these are like adding <code>λ</code> terms to the type language of the simply typed lambda calculus.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
